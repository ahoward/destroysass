#!/usr/bin/env bun
//
// bny ps — show running bny processes
//
// discovers bny processes via:
//   1. dispatcher pidfile (.bny/bny.pid)
//   2. child pidfiles (.bny/children/<pid>) — catches orphans after dispatcher crash
//   3. pgrep fallback — belt + suspenders
//
// usage:
//   bny ps              # human-readable table
//   bny ps --json       # Result envelope
//

import { existsSync, readFileSync, readdirSync, unlinkSync } from "node:fs"
import { resolve } from "node:path"
import { success } from "../src/lib/result.ts"
import { find_root } from "./lib/feature.ts"

// -- args --

const argv = process.argv.slice(2)
const json_mode = argv.includes("--json")

if (argv.includes("--help") || argv.includes("-h")) {
  process.stdout.write("usage: bny ps [--json]\n")
  process.exit(0)
}

// -- types --

interface ProcInfo {
  pid:     number
  elapsed: string
  command: string
}

// -- helpers --

function is_alive(pid: number): boolean {
  try {
    process.kill(pid, 0)
    return true
  } catch {
    return false
  }
}

function ps_info(pid: number): ProcInfo | null {
  const result = Bun.spawnSync(["ps", "-o", "pid=,etime=,args=", "-p", String(pid)], {
    stdout: "pipe", stderr: "pipe",
  })
  if (result.exitCode !== 0) return null

  const line = new TextDecoder().decode(result.stdout).trim()
  if (!line) return null

  // ps output: "  PID  ELAPSED  ARGS..."
  const match = line.match(/^\s*(\d+)\s+([\d:.-]+)\s+(.+)$/)
  if (!match) return null

  return {
    pid:     parseInt(match[1], 10),
    elapsed: match[2],
    command: match[3],
  }
}

function pgrep(pattern: string): number[] {
  const result = Bun.spawnSync(["pgrep", "-f", pattern], {
    stdout: "pipe", stderr: "pipe",
  })
  if (result.exitCode !== 0) return []

  return new TextDecoder().decode(result.stdout).trim()
    .split("\n")
    .filter(s => s.length > 0)
    .map(s => parseInt(s, 10))
    .filter(pid => pid !== process.pid && pid !== process.ppid)
}

function children_of(ppid: number): number[] {
  const result = Bun.spawnSync(["pgrep", "-P", String(ppid)], {
    stdout: "pipe", stderr: "pipe",
  })
  if (result.exitCode !== 0) return []

  return new TextDecoder().decode(result.stdout).trim()
    .split("\n")
    .filter(s => s.length > 0)
    .map(s => parseInt(s, 10))
}

// -- main --

const root = find_root()
const pidfile = resolve(root, ".bny/bny.pid")
const seen = new Set<number>()
const procs: ProcInfo[] = []

function collect(pid: number): void {
  if (seen.has(pid)) return
  seen.add(pid)

  const info = ps_info(pid)
  if (info) procs.push(info)

  // also collect children
  for (const child_pid of children_of(pid)) {
    collect(child_pid)
  }
}

// 1. check dispatcher pidfile
if (existsSync(pidfile)) {
  try {
    const pid = parseInt(readFileSync(pidfile, "utf-8").trim(), 10)
    if (pid > 0 && is_alive(pid)) {
      collect(pid)
    }
  } catch {}
}

// 2. scan child pidfiles (catches orphans after dispatcher crash)
const children_dir = resolve(root, ".bny/children")
if (existsSync(children_dir)) {
  try {
    for (const entry of readdirSync(children_dir)) {
      const pid = parseInt(entry, 10)
      if (pid > 0 && is_alive(pid)) {
        collect(pid)
      } else if (pid > 0) {
        // stale pidfile — reap it
        try { unlinkSync(resolve(children_dir, entry)) } catch {}
      }
    }
  } catch {}
}

// 3. find bny subcommand processes (belt + suspenders with pidfiles)
for (const pid of pgrep("bny/(implement|review|specify|plan|tasks|status|ps)")) {
  collect(pid)
}

// -- output --

if (json_mode) {
  const meta = {
    path: "/bny/ps",
    timestamp: new Date().toISOString(),
    duration_ms: 0,
  }
  const result = success({ processes: procs, count: procs.length }, meta)
  process.stdout.write(JSON.stringify(result, null, 2) + "\n")
} else {
  if (procs.length === 0) {
    process.stdout.write("no bny processes running\n")
  } else {
    process.stdout.write(`PID     ELAPSED   COMMAND\n`)
    for (const p of procs) {
      const pid_str = String(p.pid).padEnd(8)
      const elapsed_str = p.elapsed.padEnd(10)
      process.stdout.write(`${pid_str}${elapsed_str}${p.command}\n`)
    }
  }
}
